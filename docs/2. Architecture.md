# ARCHITECTURE.md - Wani

**Version:** 1.0  
**Created:** 2024-12-20  
**Last Updated:** 2024-12-20  
**Maintained by:** [Tu Nombre]

---

## Project Overview

**Product:** Wani - Cross-Border Payment System  
**Type:** Complete Financial System (Web + Mobile + Backend + Blockchain)  
**Status:** 🟡 Planning

**MVP Scope:**
Sistema de pagos cross-border de bajo costo que permite mover dinero entre USA/Canadá y México, gastarlo localmente con NFC/QR, y hacer cash-out cuando sea necesario. Incluye dos apps móviles (Wani para usuarios + Wani Business para comerciantes), backend API, y integración con Stellar blockchain.

**Target Launch:** 16 semanas (4 meses) - 8 sprints de 2 semanas

---

## System Architecture

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Cloudflare CDN                        │
│                  (DDoS Protection)                       │
└────────────────────────┬────────────────────────────────┘
                         │
        ┌────────────────┴────────────────┐
        │                                  │
┌───────▼────────┐              ┌─────────▼────────┐
│   Web App PWA  │              │  Mobile Apps     │
│  (React + TS)  │              │  (React Native)  │
│                │              │                  │
│  - Wani Web    │              │  - Wani iOS      │
│  - Dashboard   │              │  - Wani Android  │
│                │              │  - Business iOS  │
└───────┬────────┘              │  - Business And  │
        │                       └─────────┬────────┘
        └────────────────┬────────────────┘
                         │
                ┌────────▼────────┐
                │   API Gateway   │
                │   (Rate Limit)  │
                │   (Auth Check)  │
                └────────┬────────┘
                         │
        ┌────────────────┴────────────────┐
        │                                  │
┌───────▼────────┐              ┌─────────▼────────┐
│  FastAPI       │              │  FastAPI         │
│  Instance 1    │              │  Instance 2      │
│  (Stateless)   │              │  (Stateless)     │
└───────┬────────┘              └─────────┬────────┘
        │                                  │
        └────────────────┬────────────────┘
                         │
        ┌────────────────┴────────────────┐
        │                                  │
┌───────▼────────┐              ┌─────────▼────────┐
│  PostgreSQL    │              │  Redis Cache     │
│  (Supabase)    │              │  (Upstash)       │
│                │              │                  │
│  - Users       │              │  - Sessions      │
│  - Wallets     │              │  - Rate Limits   │
│  - Txs         │              │  - Temp Data     │
└───────┬────────┘              └──────────────────┘
        │
        ├──────────────────┬──────────────────┐
        │                  │                  │
┌───────▼────────┐ ┌──────▼───────┐ ┌────────▼────────┐
│ Stellar        │ │   Circular   │ │     Bitso       │
│ Network        │ │   (Cash-in)  │ │   (Cash-out)    │
│                │ │              │ │                 │
│ - USDC Txs     │ │ - USD/CAD    │ │ - MXN Bank      │
│ - Wallets      │ │   Accounts   │ │ - Crypto Exit   │
└────────────────┘ └──────────────┘ └─────────────────┘

        ┌──────────────────────────────────┐
        │     Background Workers           │
        │     (Celery + Redis)             │
        │                                  │
        │  - KYC Processing                │
        │  - Transaction Monitoring        │
        │  - Email Notifications           │
        │  - Compliance Reports            │
        └──────────────────────────────────┘

        ┌──────────────────────────────────┐
        │     Monitoring & Logging         │
        │                                  │
        │  - Sentry (Errors)               │
        │  - DataDog (Metrics)             │
        │  - CloudWatch (Logs)             │
        └──────────────────────────────────┘
```

### Architecture Principles

- **Separation of Concerns:** Frontend (React/RN) / Backend (FastAPI) / Blockchain (Stellar) / Database (PostgreSQL) claramente separados
- **Stateless Design:** Backend no mantiene estado de sesión, todo en JWT + Redis para scale horizontal
- **API-First:** Backend expone API RESTful documentada con OpenAPI
- **Security by Default:** Autenticación en todos los endpoints protegidos, rate limiting, encryption at rest
- **Scalability:** Diseñado para escalar horizontalmente (múltiples instancias FastAPI sin shared state)
- **Blockchain as Infrastructure:** Stellar es invisible al usuario, solo infraestructura de bajo costo
- **Idempotency:** Transacciones críticas son idempotent para evitar duplicados
- **Async-First:** Operaciones pesadas (KYC, emails, compliance) en background workers

---

## Technology Stack

### Frontend Web (PWA)

```yaml
Framework: React 18.2+
Language: TypeScript 5.0+
UI Library: Tailwind CSS 3.3+
State Management: Zustand 4.4+
HTTP Client: TanStack Query (React Query) 5.0+
Router: React Router 6.20+
Form Handling: React Hook Form 7.48+
Build Tool: Vite 5.0+
Testing: Vitest + React Testing Library
E2E Testing: Playwright
Linting: ESLint + Prettier
Package Manager: pnpm
PWA: Workbox (service workers)
```

### Frontend Mobile

```yaml
Framework: React Native 0.73+
Runtime: Expo SDK 50+
Language: TypeScript 5.0+
Styling: NativeWind (Tailwind for RN)
State Management: Zustand 4.4+
HTTP Client: TanStack Query 5.0+
Navigation: React Navigation 6+
NFC: expo-nfc (react-native-nfc-manager backup)
QR Scanner: expo-camera + expo-barcode-scanner
Biometrics: expo-local-authentication
Push Notifications: expo-notifications
Storage: expo-secure-store (encrypted)
Build: EAS (Expo Application Services)
Testing: Jest + React Native Testing Library
```

### Backend API

```yaml
Language: Python 3.11+
Framework: FastAPI 0.108+
Database: PostgreSQL 15+ (via Supabase)
ORM: SQLAlchemy 2.0+
Migrations: Alembic
Cache: Redis 7+ (Upstash)
Queue: Celery 5.3+ (Redis backend)
Authentication: Supabase Auth + Custom JWT
Validation: Pydantic 2.5+
Blockchain: Stellar SDK (py-stellar-base 9.0+)
File Upload: AWS S3 / Cloudinary
Email: Resend / SendGrid
Logging: Structlog + CloudWatch
Testing: Pytest + Pytest-asyncio
API Docs: FastAPI auto-generated (OpenAPI/Swagger)
CORS: FastAPI CORS middleware
Rate Limiting: slowapi
```

### DevOps & Infrastructure

```yaml
Hosting Frontend: Vercel (PWA) + CDN
Hosting Mobile: EAS Build + App Store + Google Play
Hosting Backend: Railway / Fly.io (containerized)
Database: Supabase (managed PostgreSQL)
Cache: Upstash (managed Redis)
Blockchain: Stellar Horizon API (mainnet + testnet)
Version Control: Git + GitHub
CI/CD: GitHub Actions
Containerization: Docker + Docker Compose
Monitoring: Sentry (errors) + DataDog (metrics)
Logging: CloudWatch / Railway logs
CDN: Cloudflare
Domain: Cloudflare DNS
SSL: Cloudflare + Let's Encrypt
Secrets: GitHub Secrets + Railway/Fly.io env vars
```

### External Integrations

```yaml
Cash-in: Circular API (USA/CAN accounts)
Cash-out: Bitso API (MXN → Bank)
Blockchain: Stellar Network (USDC transfers)
KYC/Identity: Stripe Identity / Onfido
Push Notifications: Expo Push Notifications
Analytics: PostHog / Mixpanel
Error Tracking: Sentry
Customer Support: Intercom / Zendesk
```

---

## Project Structure

### Complete Folder Structure

```
wani/
│
├── apps/
│   ├── web/                          # PWA Web App
│   │   ├── src/
│   │   │   ├── app/
│   │   │   │   ├── features/         # Feature modules
│   │   │   │   │   ├── auth/
│   │   │   │   │   │   ├── components/
│   │   │   │   │   │   │   ├── LoginForm.tsx
│   │   │   │   │   │   │   ├── RegisterForm.tsx
│   │   │   │   │   │   │   └── ForgotPasswordForm.tsx
│   │   │   │   │   │   ├── hooks/
│   │   │   │   │   │   │   ├── useAuth.ts
│   │   │   │   │   │   │   └── useLogin.ts
│   │   │   │   │   │   ├── services/
│   │   │   │   │   │   │   └── authService.ts
│   │   │   │   │   │   └── types/
│   │   │   │   │   │       └── auth.types.ts
│   │   │   │   │   ├── wallet/
│   │   │   │   │   │   ├── components/
│   │   │   │   │   │   │   ├── WalletBalance.tsx
│   │   │   │   │   │   │   ├── TransactionList.tsx
│   │   │   │   │   │   │   └── SendMoneyForm.tsx
│   │   │   │   │   │   ├── hooks/
│   │   │   │   │   │   ├── services/
│   │   │   │   │   │   └── types/
│   │   │   │   │   ├── payments/
│   │   │   │   │   │   ├── components/
│   │   │   │   │   │   ├── hooks/
│   │   │   │   │   │   └── services/
│   │   │   │   │   ├── kyc/
│   │   │   │   │   └── cashout/
│   │   │   │   │
│   │   │   │   ├── shared/           # Shared components
│   │   │   │   │   ├── components/
│   │   │   │   │   │   ├── Button.tsx
│   │   │   │   │   │   ├── Input.tsx
│   │   │   │   │   │   ├── Modal.tsx
│   │   │   │   │   │   └── LoadingSpinner.tsx
│   │   │   │   │   ├── hooks/
│   │   │   │   │   │   ├── useDebounce.ts
│   │   │   │   │   │   └── useLocalStorage.ts
│   │   │   │   │   ├── utils/
│   │   │   │   │   │   ├── format.ts
│   │   │   │   │   │   ├── validation.ts
│   │   │   │   │   │   └── constants.ts
│   │   │   │   │   └── types/
│   │   │   │   │       └── common.types.ts
│   │   │   │   │
│   │   │   │   ├── core/              # Core services
│   │   │   │   │   ├── api/
│   │   │   │   │   │   ├── client.ts
│   │   │   │   │   │   └── interceptors.ts
│   │   │   │   │   ├── auth/
│   │   │   │   │   │   └── authGuard.ts
│   │   │   │   │   ├── config/
│   │   │   │   │   │   └── env.ts
│   │   │   │   │   └── store/
│   │   │   │   │       └── store.ts
│   │   │   │   │
│   │   │   │   ├── layouts/
│   │   │   │   │   ├── DashboardLayout.tsx
│   │   │   │   │   └── AuthLayout.tsx
│   │   │   │   │
│   │   │   │   └── routes/
│   │   │   │       ├── index.tsx
│   │   │   │       └── ProtectedRoute.tsx
│   │   │   │
│   │   │   ├── assets/
│   │   │   │   ├── images/
│   │   │   │   ├── icons/
│   │   │   │   └── fonts/
│   │   │   │
│   │   │   ├── styles/
│   │   │   │   └── global.css
│   │   │   │
│   │   │   ├── main.tsx
│   │   │   └── App.tsx
│   │   │
│   │   ├── public/
│   │   │   ├── manifest.json
│   │   │   ├── sw.js
│   │   │   └── icons/
│   │   │
│   │   ├── tests/
│   │   │   ├── unit/
│   │   │   ├── integration/
│   │   │   └── e2e/
│   │   │
│   │   ├── .env.example
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   ├── vite.config.ts
│   │   ├── tailwind.config.js
│   │   └── playwright.config.ts
│   │
│   ├── mobile/                        # React Native Apps
│   │   ├── src/
│   │   │   ├── app/
│   │   │   │   ├── features/         # Same structure as web
│   │   │   │   │   ├── auth/
│   │   │   │   │   ├── wallet/
│   │   │   │   │   ├── payments/
│   │   │   │   │   ├── nfc/
│   │   │   │   │   └── qr/
│   │   │   │   ├── shared/
│   │   │   │   ├── core/
│   │   │   │   ├── navigation/
│   │   │   │   │   ├── RootNavigator.tsx
│   │   │   │   │   └── AuthNavigator.tsx
│   │   │   │   └── screens/
│   │   │   │       ├── HomeScreen.tsx
│   │   │   │       ├── WalletScreen.tsx
│   │   │   │       └── PaymentScreen.tsx
│   │   │   │
│   │   │   ├── assets/
│   │   │   └── App.tsx
│   │   │
│   │   ├── app.json
│   │   ├── eas.json
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   └── mobile-business/               # React Native Business App
│       └── [similar structure]
│
├── backend/
│   ├── app/
│   │   ├── api/
│   │   │   ├── v1/
│   │   │   │   ├── routes/
│   │   │   │   │   ├── __init__.py
│   │   │   │   │   ├── auth.py
│   │   │   │   │   ├── users.py
│   │   │   │   │   ├── wallets.py
│   │   │   │   │   ├── transactions.py
│   │   │   │   │   ├── payments.py
│   │   │   │   │   ├── merchants.py
│   │   │   │   │   └── kyc.py
│   │   │   │   │
│   │   │   │   └── __init__.py
│   │   │   │
│   │   │   └── deps.py              # Dependencies
│   │   │
│   │   ├── core/
│   │   │   ├── config.py             # Settings
│   │   │   ├── security.py           # Auth/Security
│   │   │   └── database.py           # DB connection
│   │   │
│   │   ├── models/
│   │   │   ├── __init__.py
│   │   │   ├── user.py
│   │   │   ├── wallet.py
│   │   │   ├── transaction.py
│   │   │   ├── payment.py
│   │   │   └── merchant.py
│   │   │
│   │   ├── schemas/                  # Pydantic schemas
│   │   │   ├── __init__.py
│   │   │   ├── user.py
│   │   │   ├── wallet.py
│   │   │   ├── transaction.py
│   │   │   └── payment.py
│   │   │
│   │   ├── services/                 # Business logic
│   │   │   ├── __init__.py
│   │   │   ├── auth_service.py
│   │   │   ├── wallet_service.py
│   │   │   ├── transaction_service.py
│   │   │   ├── payment_service.py
│   │   │   ├── stellar_service.py
│   │   │   ├── circular_service.py
│   │   │   ├── bitso_service.py
│   │   │   └── kyc_service.py
│   │   │
│   │   ├── workers/                  # Celery tasks
│   │   │   ├── __init__.py
│   │   │   ├── celery_app.py
│   │   │   ├── kyc_tasks.py
│   │   │   ├── notification_tasks.py
│   │   │   └── compliance_tasks.py
│   │   │
│   │   ├── middleware/
│   │   │   ├── __init__.py
│   │   │   ├── auth.py
│   │   │   ├── rate_limit.py
│   │   │   └── logging.py
│   │   │
│   │   ├── utils/
│   │   │   ├── __init__.py
│   │   │   ├── crypto.py
│   │   │   ├── validators.py
│   │   │   └── formatters.py
│   │   │
│   │   └── main.py                   # FastAPI app
│   │
│   ├── alembic/                      # Database migrations
│   │   ├── versions/
│   │   └── env.py
│   │
│   ├── tests/
│   │   ├── unit/
│   │   ├── integration/
│   │   └── conftest.py
│   │
│   ├── scripts/
│   │   ├── init_db.py
│   │   └── seed_data.py
│   │
│   ├── .env.example
│   ├── requirements.txt
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── alembic.ini
│
├── docs/
│   ├── PRD.md
│   ├── ARCHITECTURE.md
│   ├── PRODUCT-BACKLOG.md
│   ├── API.md
│   ├── DEPLOYMENT.md
│   └── sprints/
│       ├── sprint-01/
│       │   ├── planning.md
│       │   ├── tasks.md
│       │   ├── review.md
│       │   └── retrospective.md
│       └── sprint-02/
│
├── .github/
│   └── workflows/
│       ├── ci-backend.yml
│       ├── ci-web.yml
│       ├── ci-mobile.yml
│       └── deploy-production.yml
│
├── .gitignore
├── README.md
├── CLAUDE.md                         # Rules for Claude Code
└── docker-compose.yml                # Local development
```

---

## Code Conventions

### Naming Conventions

#### Frontend (React/TypeScript)

```typescript
// Files
UserProfile.tsx; // Components (PascalCase)
useAuth.ts; // Hooks (camelCase with 'use' prefix)
walletService.ts; // Services (camelCase)
user.types.ts; // Types (camelCase)
constants.ts; // Constants
formatCurrency.ts; // Utilities (camelCase)

// Code
interface User {} // Interfaces (PascalCase)
type UserRole = string; // Types (PascalCase)
const API_URL = "..."; // Constants (UPPER_SNAKE_CASE)
function fetchUser() {} // Functions (camelCase)
const userName = ""; // Variables (camelCase)

// Components
export const UserProfile = () => {}; // Named export (preferred)
export default UserProfile; // Default export (use sparingly)

// React Native specific
HomeScreen.tsx; // Screens (PascalCase + Screen suffix)
useNFC.ts; // Native hooks
```

#### Backend (Python/FastAPI)

```python
# Files
user_controller.py             # Controllers (snake_case)
wallet_service.py              # Services (snake_case)
transaction.py                 # Models (snake_case)
auth_schemas.py                # Schemas (snake_case)
kyc_tasks.py                   # Celery tasks (snake_case)
stellar_client.py              # Clients (snake_case)

# Code
class UserService:             # Classes (PascalCase)
class TransactionModel(Base):  # Models (PascalCase + Model suffix)

def create_user():             # Functions (snake_case)
def get_wallet_balance():      # Functions (snake_case)

user_id = "..."                # Variables (snake_case)
API_VERSION = "v1"             # Constants (UPPER_SNAKE_CASE)

# Pydantic schemas
class UserCreate(BaseModel):   # Schema classes (PascalCase)
class WalletResponse(BaseModel):
```

### Git Commit Convention

Usamos **Conventional Commits**:

```
<type>(<scope>): <subject>

<body> (opcional)

<footer> (opcional)
```

**Types:**

- `feat`: Nueva funcionalidad
- `fix`: Corrección de bug
- `docs`: Cambios en documentación
- `style`: Formato (sin cambio de código)
- `refactor`: Refactorización
- `perf`: Mejoras de performance
- `test`: Agregar o corregir tests
- `chore`: Cambios en build, configs
- `security`: Fixes de seguridad

**Scopes (ejemplos):**

- `auth`, `wallet`, `payments`, `nfc`, `stellar`, `api`, `web`, `mobile`

**Examples:**

```
feat(wallet): add USDC balance display in MXN
fix(stellar): resolve transaction timeout on testnet
docs(readme): update installation instructions
refactor(payments): simplify NFC payment flow
security(auth): add rate limiting to login endpoint
perf(api): add redis caching for user queries
```

### Code Style Guidelines

#### Frontend (TypeScript/React)

```typescript
// ✅ Functional components with TypeScript
interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

export const UserProfile: React.FC<UserProfileProps> = ({
  userId,
  onUpdate,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    fetchUser(userId);
  }, [userId]);

  const fetchUser = async (id: string) => {
    setIsLoading(true);
    try {
      const data = await userService.getById(id);
      setUser(data);
      onUpdate?.(data);
    } catch (error) {
      toast.error("Failed to load user");
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) return <LoadingSpinner />;
  if (!user) return <ErrorState />;

  return (
    <div className="p-4 bg-white rounded-lg shadow">
      <h2 className="text-xl font-bold">{user.name}</h2>
      <p className="text-gray-600">{user.email}</p>
    </div>
  );
};

// ✅ Custom hooks
export const useWallet = (userId: string) => {
  return useQuery({
    queryKey: ["wallet", userId],
    queryFn: () => walletService.getBalance(userId),
    staleTime: 30000, // 30 seconds
  });
};

// ✅ Service pattern
class WalletService {
  async getBalance(userId: string): Promise<WalletBalance> {
    const response = await apiClient.get(`/wallets/${userId}`);
    return response.data;
  }

  async sendMoney(data: SendMoneyDto): Promise<Transaction> {
    const response = await apiClient.post("/transactions", data);
    return response.data;
  }
}

export const walletService = new WalletService();
```

#### Backend (Python/FastAPI)

```python
# ✅ Pydantic schemas for validation
class UserCreate(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=8, max_length=100)
    full_name: str = Field(..., min_length=2, max_length=100)

class UserResponse(BaseModel):
    id: str
    email: EmailStr
    full_name: str
    created_at: datetime

    class Config:
        from_attributes = True

# ✅ Route handlers with dependency injection
@router.post("/users", response_model=UserResponse, status_code=201)
async def create_user(
    user_data: UserCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_admin_user)
):
    """Create a new user (admin only)."""
    try:
        user = await user_service.create(db, user_data)
        return user
    except EmailAlreadyExistsError as e:
        raise HTTPException(
            status_code=409,
            detail={"message": str(e), "code": "EMAIL_EXISTS"}
        )
    except Exception as e:
        logger.error(f"Error creating user: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# ✅ Service layer with business logic
class UserService:
    async def create(self, db: Session, user_data: UserCreate) -> User:
        # Check if email exists
        existing = db.query(User).filter(User.email == user_data.email).first()
        if existing:
            raise EmailAlreadyExistsError("Email already registered")

        # Hash password
        hashed_password = get_password_hash(user_data.password)

        # Create user
        user = User(
            email=user_data.email,
            password=hashed_password,
            full_name=user_data.full_name
        )

        db.add(user)
        db.commit()
        db.refresh(user)

        # Create wallet for user
        await wallet_service.create_for_user(db, user.id)

        return user

user_service = UserService()

# ✅ Async Stellar integration
class StellarService:
    def __init__(self):
        self.server = Server(horizon_url=settings.STELLAR_HORIZON_URL)

    async def send_usdc(
        self,
        from_wallet: str,
        to_wallet: str,
        amount: Decimal
    ) -> str:
        """Send USDC via Stellar. Returns transaction hash."""
        try:
            # Build transaction
            source_account = await self.server.load_account(from_wallet)

            transaction = (
                TransactionBuilder(
                    source_account=source_account,
                    network_passphrase=Network.PUBLIC_NETWORK_PASSPHRASE,
                    base_fee=100
                )
                .append_payment_op(
                    destination=to_wallet,
                    asset=Asset.native() if amount < 1 else USDC_ASSET,
                    amount=str(amount)
                )
                .set_timeout(30)
                .build()
            )

            # Sign and submit
            transaction.sign(settings.STELLAR_SECRET_KEY)
            response = await self.server.submit_transaction(transaction)

            return response['hash']

        except Exception as e:
            logger.error(f"Stellar transaction failed: {e}")
            raise StellarTransactionError(str(e))

stellar_service = StellarService()
```

---

## API Design

### RESTful API Structure

```
Base URL: https://api.wani.app/v1

Authentication:
POST   /auth/register              # Register new user
POST   /auth/login                 # Login (returns access + refresh tokens)
POST   /auth/refresh               # Refresh access token
POST   /auth/logout                # Logout (invalidate tokens)
POST   /auth/forgot-password       # Request password reset
POST   /auth/reset-password        # Reset password with token
GET    /auth/verify-email/:token   # Verify email
POST   /auth/resend-verification   # Resend verification email

Users:
GET    /users/me                   # Get current user
PATCH  /users/me                   # Update current user
DELETE /users/me                   # Delete current user
POST   /users/me/avatar            # Upload avatar

KYC:
POST   /kyc/documents              # Upload KYC documents
GET    /kyc/status                 # Get KYC verification status
POST   /kyc/verify                 # Trigger verification

Wallets:
GET    /wallets/me                 # Get my wallet
GET    /wallets/me/balance         # Get balance (MXN + USDC)
GET    /wallets/me/address         # Get Stellar wallet address

Transactions:
GET    /transactions               # List my transactions (paginated)
GET    /transactions/:id           # Get specific transaction
POST   /transactions/send          # Send money cross-border
POST   /transactions/cashout       # Cash-out to Bitso

Payments (NFC/QR):
POST   /payments/qr/generate       # Generate payment QR
POST   /payments/qr/scan           # Process scanned QR
POST   /payments/nfc/initiate      # Initiate NFC payment
POST   /payments/nfc/complete      # Complete NFC payment
GET    /payments/:id               # Get payment details

Merchants (Business app):
GET    /merchants/me               # Get merchant profile
PATCH  /merchants/me               # Update merchant profile
GET    /merchants/me/stats         # Get merchant statistics
GET    /merchants/me/transactions  # Get merchant transactions
POST   /merchants/me/qr            # Generate static merchant QR

Admin (future):
GET    /admin/users                # List all users
GET    /admin/transactions         # List all transactions
POST   /admin/kyc/:id/approve      # Approve KYC
POST   /admin/kyc/:id/reject       # Reject KYC
```

### Request/Response Format

#### Success Response

```json
{
  "success": true,
  "data": {
    "id": "user_123",
    "email": "carlos@example.com",
    "full_name": "Carlos Rodriguez",
    "kyc_level": "basic",
    "created_at": "2024-12-20T10:00:00Z"
  },
  "message": "User retrieved successfully"
}
```

#### Success with Pagination

```json
{
  "success": true,
  "data": [
    { "id": "tx_1", "amount": 500, "type": "receive" },
    { "id": "tx_2", "amount": 250, "type": "payment" }
  ],
  "meta": {
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 156,
      "total_pages": 8,
      "has_next": true,
      "has_prev": false
    }
  }
}
```

#### Error Response

```json
{
  "success": false,
  "error": {
    "message": "Validation failed",
    "code": "VALIDATION_ERROR",
    "status_code": 400,
    "details": [
      {
        "field": "email",
        "message": "Invalid email format"
      },
      {
        "field": "password",
        "message": "Password must be at least 8 characters"
      }
    ],
    "timestamp": "2024-12-20T10:00:00Z"
  }
}
```

### HTTP Status Codes

```
200 OK                    # Success
201 Created               # Resource created
204 No Content            # Success with no response body
400 Bad Request           # Invalid input
401 Unauthorized          # Not authenticated
403 Forbidden             # Not authorized
404 Not Found             # Resource not found
409 Conflict              # Resource conflict (e.g. email exists)
422 Unprocessable Entity  # Validation error
429 Too Many Requests     # Rate limit exceeded
500 Internal Server Error # Server error
502 Bad Gateway           # External service error
503 Service Unavailable   # Maintenance or overload
```

### Authentication Flow

```typescript
// 1. Login
POST /auth/login
{
  "email": "user@example.com",
  "password": "password123"
}

// Response:
{
  "success": true,
  "data": {
    "user": { ... },
    "access_token": "eyJ...",  // Valid 15 minutes
    "refresh_token": "eyJ...",  // Valid 7 days
    "token_type": "Bearer"
  }
}

// 2. Use access token
GET /wallets/me
Headers: {
  "Authorization": "Bearer eyJ..."
}

// 3. When access token expires, refresh
POST /auth/refresh
{
  "refresh_token": "eyJ..."
}

// Response: New access token
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "token_type": "Bearer"
  }
}
```

---

## Database Design

### Schema Overview

```sql
-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    kyc_level VARCHAR(20) DEFAULT 'none', -- none, basic, full
    kyc_documents JSONB,
    role VARCHAR(20) DEFAULT 'user', -- user, merchant, admin
    is_verified BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_kyc_level ON users(kyc_level);

-- Wallets table
CREATE TABLE wallets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    balance_mxn DECIMAL(18, 2) DEFAULT 0.00,
    balance_usdc DECIMAL(18, 6) DEFAULT 0.000000,
    stellar_public_key VARCHAR(56) UNIQUE NOT NULL,
    stellar_secret_key TEXT NOT NULL, -- Encrypted
    status VARCHAR(20) DEFAULT 'active', -- active, frozen, closed
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_wallets_user_id ON wallets(user_id);
CREATE INDEX idx_wallets_stellar_key ON wallets(stellar_public_key);

-- Transactions table
CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type VARCHAR(20) NOT NULL, -- receive, send, payment, cashout
    from_user_id UUID REFERENCES users(id),
    to_user_id UUID REFERENCES users(id),
    from_wallet_id UUID REFERENCES wallets(id),
    to_wallet_id UUID REFERENCES wallets(id),
    amount_mxn DECIMAL(18, 2),
    amount_usdc DECIMAL(18, 6),
    fee_mxn DECIMAL(18, 2) DEFAULT 0.00,
    exchange_rate DECIMAL(10, 4),
    status VARCHAR(20) DEFAULT 'pending', -- pending, processing, completed, failed, cancelled
    stellar_tx_hash VARCHAR(64),
    metadata JSONB, -- Flexible field for extra data
    error_message TEXT,
    idempotency_key VARCHAR(64) UNIQUE,
    created_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP
);

CREATE INDEX idx_transactions_from_user ON transactions(from_user_id);
CREATE INDEX idx_transactions_to_user ON transactions(to_user_id);
CREATE INDEX idx_transactions_status ON transactions(status);
CREATE INDEX idx_transactions_type ON transactions(type);
CREATE INDEX idx_transactions_created_at ON transactions(created_at DESC);
CREATE INDEX idx_transactions_stellar_hash ON transactions(stellar_tx_hash);
CREATE UNIQUE INDEX idx_transactions_idempotency ON transactions(idempotency_key);

-- Merchants table
CREATE TABLE merchants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    business_name VARCHAR(255) NOT NULL,
    business_type VARCHAR(100),
    static_qr_code TEXT, -- Base64 or URL
    nfc_enabled BOOLEAN DEFAULT TRUE,
    commission_rate DECIMAL(5, 2) DEFAULT 1.00, -- 1.00%
    subscription_plan VARCHAR(20) DEFAULT 'payg', -- payg, basic, pro, enterprise
    monthly_volume_mxn DECIMAL(18, 2) DEFAULT 0.00,
    total_transactions INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_merchants_user_id ON merchants(user_id);
CREATE INDEX idx_merchants_business_name ON merchants(business_name);

-- Payments table (NFC/QR payments)
CREATE TABLE payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    transaction_id UUID NOT NULL REFERENCES transactions(id),
    merchant_id UUID NOT NULL REFERENCES merchants(id),
    customer_id UUID NOT NULL REFERENCES users(id),
    method VARCHAR(10) NOT NULL, -- nfc, qr
    amount_mxn DECIMAL(18, 2) NOT NULL,
    commission_mxn DECIMAL(18, 2) NOT NULL,
    receipt_url TEXT,
    location_data JSONB, -- Lat/lng, device info
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_payments_merchant ON payments(merchant_id);
CREATE INDEX idx_payments_customer ON payments(customer_id);
CREATE INDEX idx_payments_created_at ON payments(created_at DESC);

-- KYC Verifications table
CREATE TABLE kyc_verifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'pending', -- pending, approved, rejected, expired
    level VARCHAR(20) NOT NULL, -- basic, full
    documents JSONB NOT NULL, -- List of document URLs + types
    reviewed_by UUID REFERENCES users(id),
    reviewed_at TIMESTAMP,
    rejection_reason TEXT,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_kyc_user_id ON kyc_verifications(user_id);
CREATE INDEX idx_kyc_status ON kyc_verifications(status);
```

### Relationships

```
User 1:1 Wallet
User 1:N Transaction (as sender or receiver)
User 1:1 Merchant (optional)
Merchant 1:N Payment
Transaction 1:1 Payment (if payment type)
User 1:N KYC_Verification
```

---

## Security Standards

### Authentication & Authorization

```python
# JWT Configuration
JWT_SECRET = env("JWT_SECRET")  # 256-bit key
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 15
REFRESH_TOKEN_EXPIRE_DAYS = 7

# Password hashing
from passlib.context import CryptContext
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)

# Role-Based Access Control
class Permission(str, Enum):
    READ_OWN = "read:own"
    UPDATE_OWN = "update:own"
    DELETE_OWN = "delete:own"
    READ_ALL = "read:all"
    CREATE_ALL = "create:all"
    UPDATE_ALL = "update:all"
    DELETE_ALL = "delete:all"

ROLE_PERMISSIONS = {
    "user": [Permission.READ_OWN, Permission.UPDATE_OWN],
    "merchant": [Permission.READ_OWN, Permission.UPDATE_OWN, Permission.READ_ALL],
    "admin": [p for p in Permission]
}

# Dependency for protected routes
async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise credentials_exception

    return user
```

### Input Validation

```python
# Pydantic schemas with validation
from pydantic import BaseModel, EmailStr, Field, validator

class SendMoneyRequest(BaseModel):
    to_wallet_address: str = Field(..., min_length=56, max_length=56)
    amount_mxn: Decimal = Field(..., gt=0, le=100000)
    currency: str = Field(default="MXN")

    @validator('to_wallet_address')
    def validate_stellar_address(cls, v):
        if not v.startswith('G'):
            raise ValueError('Invalid Stellar address')
        return v

    @validator('amount_mxn')
    def validate_amount(cls, v):
        if v.as_tuple().exponent < -2:
            raise ValueError('Amount must have max 2 decimal places')
        return v

# SQL Injection prevention (SQLAlchemy ORM)
# ❌ NEVER do this:
# query = f"SELECT * FROM users WHERE email = '{email}'"

# ✅ Always use parameterized queries:
user = db.query(User).filter(User.email == email).first()
```

### Security Headers (FastAPI Middleware)

```python
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.middleware.gzip import GZipMiddleware

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://wani.app",
        "https://business.wani.app",
        "http://localhost:3000",  # Development only
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "PATCH", "DELETE"],
    allow_headers=["*"],
)

# Trusted hosts
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["wani.app", "*.wani.app", "localhost"]
)

# Compression
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Custom security headers
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    return response
```

### Rate Limiting

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Global rate limit
@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    # 100 requests per 15 minutes per IP
    pass

# Specific endpoint limits
@router.post("/auth/login")
@limiter.limit("5/minute")  # Max 5 login attempts per minute
async def login(request: Request, credentials: LoginRequest):
    pass

@router.post("/transactions/send")
@limiter.limit("10/minute")  # Max 10 transactions per minute
async def send_money(request: Request, data: SendMoneyRequest):
    pass
```

### Encryption

```python
# Encrypt Stellar secret keys at rest
from cryptography.fernet import Fernet

ENCRYPTION_KEY = env("ENCRYPTION_KEY")  # 32-byte key
cipher = Fernet(ENCRYPTION_KEY)

def encrypt_secret(secret: str) -> str:
    return cipher.encrypt(secret.encode()).decode()

def decrypt_secret(encrypted: str) -> str:
    return cipher.decrypt(encrypted.encode()).decode()

# Store in database
wallet.stellar_secret_key = encrypt_secret(secret_key)

# Use when needed
secret = decrypt_secret(wallet.stellar_secret_key)
```

---

## Environment Configuration

### Backend Environment Variables

```bash
# .env.example

# Application
NODE_ENV=production
API_VERSION=v1
PORT=8000
DEBUG=false

# Database (Supabase)
DATABASE_URL=postgresql://user:pass@db.supabase.co:5432/postgres
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key

# Redis (Upstash)
REDIS_URL=redis://default:password@redis.upstash.io:6379

# JWT & Auth
JWT_SECRET=your-super-secret-jwt-key-min-32-chars
REFRESH_TOKEN_SECRET=your-refresh-token-secret-min-32-chars
ENCRYPTION_KEY=your-encryption-key-for-stellar-secrets

# CORS
FRONTEND_WEB_URL=https://wani.app
FRONTEND_BUSINESS_URL=https://business.wani.app
ALLOWED_ORIGINS=https://wani.app,https://business.wani.app

# Stellar
STELLAR_NETWORK=public  # or 'testnet'
STELLAR_HORIZON_URL=https://horizon.stellar.org
STELLAR_HOT_WALLET_PUBLIC=GXXXXXXXXXXXXX
STELLAR_HOT_WALLET_SECRET=SXXXXXXXXXXXXX  # Keep secret!

# Circular (Cash-in)
CIRCULAR_API_KEY=your-circular-api-key
CIRCULAR_API_SECRET=your-circular-secret
CIRCULAR_WEBHOOK_SECRET=your-webhook-secret

# Bitso (Cash-out)
BITSO_API_KEY=your-bitso-key
BITSO_API_SECRET=your-bitso-secret
BITSO_WEBHOOK_SECRET=your-webhook-secret

# KYC/Identity Verification
STRIPE_IDENTITY_KEY=sk_live_xxx
# or
ONFIDO_API_KEY=your-onfido-key

# Email
RESEND_API_KEY=re_xxxxxxxxxxxx
EMAIL_FROM=noreply@wani.app
EMAIL_FROM_NAME=Wani

# File Storage
AWS_ACCESS_KEY_ID=your-aws-key
AWS_SECRET_ACCESS_KEY=your-aws-secret
AWS_S3_BUCKET=wani-uploads
AWS_REGION=us-east-1

# Monitoring
SENTRY_DSN=https://xxx@sentry.io/xxx
LOG_LEVEL=info

# Celery
CELERY_BROKER_URL=redis://default:password@redis.upstash.io:6379/0
CELERY_RESULT_BACKEND=redis://default:password@redis.upstash.io:6379/0

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_WINDOW=15  # minutes
RATE_LIMIT_MAX=100    # requests per window
```

### Frontend Environment Variables

```bash
# Web App (.env)
VITE_API_URL=https://api.wani.app/v1
VITE_WS_URL=wss://api.wani.app
VITE_SENTRY_DSN=https://xxx@sentry.io/xxx
VITE_POSTHOG_KEY=phc_xxxxxxxxxxxx
VITE_ENABLE_ANALYTICS=true

# Mobile App (.env)
EXPO_PUBLIC_API_URL=https://api.wani.app/v1
EXPO_PUBLIC_WS_URL=wss://api.wani.app
EXPO_PUBLIC_SENTRY_DSN=https://xxx@sentry.io/xxx
EXPO_PUBLIC_ENABLE_ANALYTICS=true
```

---

## Performance Optimization

### Backend Performance

```python
# Database query optimization
from sqlalchemy.orm import selectinload, joinedload

# ❌ N+1 query problem
users = db.query(User).all()
for user in users:
    wallet = user.wallet  # Separate query for each user

# ✅ Eager loading
users = db.query(User).options(selectinload(User.wallet)).all()
for user in users:
    wallet = user.wallet  # Already loaded

# Connection pooling
engine = create_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=0,
    pool_pre_ping=True,
    pool_recycle=3600
)

# Redis caching
async def get_user_balance(user_id: str, db: Session):
    cache_key = f"balance:{user_id}"

    # Try cache first
    cached = await redis.get(cache_key)
    if cached:
        return json.loads(cached)

    # Query database
    wallet = db.query(Wallet).filter(Wallet.user_id == user_id).first()
    balance = {
        "mxn": float(wallet.balance_mxn),
        "usdc": float(wallet.balance_usdc)
    }

    # Cache for 1 minute
    await redis.setex(cache_key, 60, json.dumps(balance))

    return balance

# Background tasks for heavy operations
from fastapi import BackgroundTasks

@router.post("/transactions/send")
async def send_money(
    data: SendMoneyRequest,
    background_tasks: BackgroundTasks
):
    # Create transaction immediately
    transaction = create_transaction(data)

    # Process in background
    background_tasks.add_task(process_stellar_transaction, transaction.id)

    return {"transaction_id": transaction.id, "status": "processing"}
```

### Frontend Performance

```typescript
// Code splitting
const WalletScreen = lazy(() => import('./screens/WalletScreen'));
const PaymentScreen = lazy(() => import('./screens/PaymentScreen'));

// React Query for caching
const { data: balance } = useQuery({
  queryKey: ['balance', userId],
  queryFn: () => walletService.getBalance(userId),
  staleTime: 30000, // 30 seconds
  cacheTime: 300000, // 5 minutes
});

// Memoization
const TransactionList = ({ transactions }) => {
  const sortedTransactions = useMemo(() => {
    return transactions.sort((a, b) =>
      new Date(b.created_at) - new Date(a.created_at)
    );
  }, [transactions]);

  return <FlatList data={sortedTransactions} ... />;
};

// Debouncing
import { useDebounce } from '@/hooks/useDebounce';

const SearchUsers = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearch = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearch) {
      searchUsers(debouncedSearch);
    }
  }, [debouncedSearch]);
};
```

### Performance Targets

```yaml
Backend API:
  - Response time (P50): < 100ms
  - Response time (P95): < 200ms
  - Response time (P99): < 500ms
  - Throughput: > 1000 req/s
  - Error rate: < 0.1%

Frontend Web:
  - First Contentful Paint: < 1.5s
  - Largest Contentful Paint: < 2.5s
  - Time to Interactive: < 3.5s
  - Cumulative Layout Shift: < 0.1
  - First Input Delay: < 100ms

Mobile App:
  - App launch: < 3s
  - Screen transition: < 300ms
  - NFC payment: < 3s total
  - QR scan: < 2s total

Blockchain:
  - Stellar transaction: < 10s (P99)
  - Cross-border transfer: < 15s end-to-end
```

---

## Testing Strategy

### Test Coverage Targets

```yaml
Backend:
  Statements: > 85%
  Branches: > 80%
  Functions: > 85%
  Lines: > 85%

Frontend:
  Statements: > 75%
  Branches: > 70%
  Functions: > 75%
  Lines: > 75%
```

### Testing Patterns

#### Backend Unit Tests (Pytest)

```python
# tests/unit/test_wallet_service.py
import pytest
from app.services.wallet_service import WalletService
from app.models.user import User

@pytest.fixture
def wallet_service():
    return WalletService()

@pytest.fixture
def test_user(db_session):
    user = User(email="test@test.com", full_name="Test User")
    db_session.add(user)
    db_session.commit()
    return user

def test_create_wallet_for_user(wallet_service, test_user, db_session):
    wallet = await wallet_service.create_for_user(db_session, test_user.id)

    assert wallet.user_id == test_user.id
    assert wallet.balance_mxn == Decimal("0.00")
    assert wallet.balance_usdc == Decimal("0.000000")
    assert wallet.stellar_public_key.startswith("G")
    assert wallet.status == "active"

def test_get_balance(wallet_service, test_user, db_session):
    wallet = await wallet_service.create_for_user(db_session, test_user.id)

    balance = await wallet_service.get_balance(db_session, test_user.id)

    assert balance["mxn"] == 0.00
    assert balance["usdc"] == 0.000000
```

#### Backend Integration Tests

```python
# tests/integration/test_transactions_api.py
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_send_money_success(test_user_token, test_recipient):
    response = client.post(
        "/v1/transactions/send",
        json={
            "to_wallet_address": test_recipient.wallet.stellar_public_key,
            "amount_mxn": 500.00
        },
        headers={"Authorization": f"Bearer {test_user_token}"}
    )

    assert response.status_code == 201
    data = response.json()
    assert data["success"] is True
    assert data["data"]["status"] == "processing"
    assert data["data"]["amount_mxn"] == "500.00"

def test_send_money_insufficient_balance(test_user_token):
    response = client.post(
        "/v1/transactions/send",
        json={
            "to_wallet_address": "GXXXXX",
            "amount_mxn": 999999.00
        },
        headers={"Authorization": f"Bearer {test_user_token}"}
    )

    assert response.status_code == 400
    data = response.json()
    assert data["success"] is False
    assert data["error"]["code"] == "INSUFFICIENT_BALANCE"
```

#### Frontend Unit Tests (Vitest + React Testing Library)

```typescript
// __tests__/components/WalletBalance.test.tsx
import { render, screen, waitFor } from "@testing-library/react";
import { WalletBalance } from "@/features/wallet/components/WalletBalance";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

describe("WalletBalance", () => {
  it("displays balance when loaded", async () => {
    render(
      <QueryClientProvider client={queryClient}>
        <WalletBalance userId="user_123" />
      </QueryClientProvider>
    );

    await waitFor(() => {
      expect(screen.getByText(/\$1,250.50/)).toBeInTheDocument();
    });
  });

  it("shows loading state initially", () => {
    render(
      <QueryClientProvider client={queryClient}>
        <WalletBalance userId="user_123" />
      </QueryClientProvider>
    );

    expect(screen.getByTestId("loading-spinner")).toBeInTheDocument();
  });
});
```

#### E2E Tests (Playwright)

```typescript
// e2e/payment-flow.spec.ts
import { test, expect } from "@playwright/test";

test.describe("Payment Flow", () => {
  test("user can send money to another user", async ({ page }) => {
    // Login
    await page.goto("https://wani.app/login");
    await page.fill('[data-testid="email"]', "test@test.com");
    await page.fill('[data-testid="password"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to send money
    await page.click('[data-testid="send-money-button"]');

    // Fill form
    await page.fill('[data-testid="recipient-address"]', "GXXXXX");
    await page.fill('[data-testid="amount"]', "500");
    await page.click('[data-testid="submit"]');

    // Verify success
    await expect(page.locator('[data-testid="success-message"]')).toContainText(
      "Money sent successfully"
    );

    // Check transaction appears in history
    await page.click('[data-testid="transactions-tab"]');
    await expect(
      page.locator('[data-testid="transaction-list"]')
    ).toContainText("$500.00");
  });
});
```

---

## Deployment Architecture

### Environments

#### Development

```yaml
Purpose: Local development
Frontend Web: http://localhost:5173 (Vite dev server)
Frontend Mobile: Expo Go app
Backend: http://localhost:8000
Database: Local PostgreSQL or Supabase dev instance
Stellar: Testnet
Redis: Local or Upstash free tier
Hot Reload: Enabled
Debugging: Full source maps
Mocks: External services mocked (Circular, Bitso)
```

#### Staging

```yaml
Purpose: Pre-production testing
Frontend Web: https://staging.wani.app
Frontend Mobile: TestFlight (iOS) + Internal Testing (Android)
Backend: https://api-staging.wani.app
Database: Supabase staging instance (sanitized prod data)
Stellar: Testnet
Redis: Upstash staging
Monitoring: Full Sentry + DataDog
Error Tracking: All errors logged
Performance: Production-like resources
```

#### Production

```yaml
Purpose: Live application
Frontend Web: https://wani.app (Vercel)
Frontend Mobile: App Store + Google Play
Backend: https://api.wani.app (Railway/Fly.io)
Database: Supabase production (HA, backups)
Stellar: Mainnet
Redis: Upstash production (HA)
Monitoring: Full monitoring + alerts
Auto-scaling: Enabled (backend)
Backups: Automated daily
CDN: Cloudflare
SSL: Automatic (Cloudflare)
```

### CI/CD Pipeline (GitHub Actions)

```yaml
# .github/workflows/backend-ci.yml

name: Backend CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - "backend/**"
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt

      - name: Run linting
        run: |
          cd backend
          flake8 app/
          black --check app/

      - name: Run type checking
        run: |
          cd backend
          mypy app/

      - name: Run tests
        run: |
          cd backend
          pytest --cov=app --cov-report=xml

      - name: Upload coverage
        uses: codecov/codecov-action@v3

  build-and-deploy:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build Docker image
        run: |
          cd backend
          docker build -t wani-backend:${{ github.sha }} .

      - name: Deploy to Railway
        run: |
          # Railway deployment
          railway up --service backend
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

      - name: Run smoke tests
        run: |
          curl https://api.wani.app/health

      - name: Notify team
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "✅ Backend deployed successfully to production"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
```

```yaml
# .github/workflows/mobile-ci.yml

name: Mobile CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - "apps/mobile/**"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          cd apps/mobile
          npm install

      - name: Run linting
        run: |
          cd apps/mobile
          npm run lint

      - name: Run type checking
        run: |
          cd apps/mobile
          npm run type-check

      - name: Run tests
        run: |
          cd apps/mobile
          npm test

  build-ios:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: Build iOS
        run: |
          cd apps/mobile
          eas build --platform ios --profile production --non-interactive

      - name: Submit to TestFlight
        run: |
          cd apps/mobile
          eas submit --platform ios --latest

  build-android:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: Build Android
        run: |
          cd apps/mobile
          eas build --platform android --profile production --non-interactive

      - name: Submit to Google Play
        run: |
          cd apps/mobile
          eas submit --platform android --latest
```

### Deployment Checklist

```markdown
## Pre-Deployment

- [ ] All tests passing (unit + integration + e2e)
- [ ] Code reviewed and approved
- [ ] Environment variables updated in hosting platform
- [ ] Database migrations prepared and tested
- [ ] Backup taken (database + Redis if needed)
- [ ] Changelog updated (CHANGELOG.md)
- [ ] Version bumped (package.json / pyproject.toml)
- [ ] Stellar integration tested on testnet
- [ ] External APIs tested (Circular, Bitso)

## Deployment

- [ ] Run database migrations
- [ ] Deploy backend to Railway/Fly.io
- [ ] Deploy frontend to Vercel
- [ ] Update mobile apps via EAS
- [ ] Clear CDN cache (Cloudflare)
- [ ] Verify all services healthy

## Post-Deployment

- [ ] Smoke tests passed (critical paths working)
- [ ] Monitoring dashboards checked (Sentry, DataDog)
- [ ] Error rates normal (< 0.1%)
- [ ] Performance metrics acceptable (< 200ms P95)
- [ ] Stellar transactions working on mainnet
- [ ] External integrations working (Circular, Bitso)
- [ ] Team notified (Slack/Discord)
- [ ] Update status page if applicable

## Rollback Plan

If deployment fails:

1. Revert code to previous commit
2. Redeploy last known good version
3. Rollback database migrations if needed
4. Clear caches
5. Notify team
6. Post-mortem within 24 hours
```

---

## Monitoring & Logging

### Logging Strategy

```python
# Backend logging with Structlog
import structlog

logger = structlog.get_logger()

# Usage
logger.info("user_created", user_id=user.id, email=user.email)
logger.error("stellar_transaction_failed",
             user_id=user.id,
             amount=amount,
             error=str(e))
logger.warning("kyc_verification_pending",
               user_id=user.id,
               days_pending=days)

# Log levels
# DEBUG: Detailed information for diagnosing issues
# INFO: General informational messages
# WARNING: Warning messages for potentially harmful situations
# ERROR: Error messages for serious problems
# CRITICAL: Critical messages for very serious problems

# Structured logging format (JSON)
{
  "timestamp": "2024-12-20T10:00:00Z",
  "level": "info",
  "event": "user_created",
  "user_id": "user_123",
  "email": "carlos@example.com",
  "ip_address": "192.168.1.1",
  "request_id": "req_abc123"
}
```

```typescript
// Frontend logging with Sentry
import * as Sentry from "@sentry/react-native";

// Capture errors
try {
  await sendMoney(data);
} catch (error) {
  Sentry.captureException(error, {
    tags: {
      feature: "payments",
      action: "send_money",
    },
    contexts: {
      user: {
        id: userId,
        email: userEmail,
      },
      transaction: {
        amount: amount,
        currency: "MXN",
      },
    },
  });
}

// Custom breadcrumbs
Sentry.addBreadcrumb({
  category: "auth",
  message: "User logged in",
  level: "info",
});
```

### Monitoring Metrics

```yaml
Infrastructure (DataDog):
  - CPU usage (target: < 70% average)
  - Memory usage (target: < 80% average)
  - Disk I/O (target: < 80% capacity)
  - Network traffic (inbound/outbound)
  - Database connections (target: < 80% pool size)
  - Redis memory usage

Application (Custom + DataDog):
  - Request rate (requests/second)
  - Error rate (target: < 0.1%)
  - Response time (P50, P95, P99)
  - Active users (DAU, WAU, MAU)
  - WebSocket connections
  - Background job queue length

Business (PostHog / Mixpanel):
  - User registrations (daily/weekly/monthly)
  - KYC completions
  - Wallet activations (users with balance > $500 MXN)
  - Cross-border transactions (count + volume USD)
  - NFC/QR payments (count + volume MXN)
  - Cash-outs (count + volume)
  - Merchant signups
  - Transaction success rate (target: > 99%)
  - Average transaction time (target: < 10s)
  - User retention (D1, D7, D30)
  - Conversion funnel (signup → KYC → first transaction)

Stellar Blockchain:
  - Transaction success rate (target: > 99.9%)
  - Average confirmation time (target: < 5s)
  - Wallet balances (hot wallet monitoring)
  - USDC liquidity
  - Stellar network congestion

External APIs:
  - Circular API health + response time
  - Bitso API health + response time
  - Stellar Horizon availability
  - Supabase database health
```

### Alerting Rules

```yaml
Critical Alerts (PagerDuty - immediate):
  - Error rate > 1% for 5 minutes
  - API response time P95 > 1s for 5 minutes
  - Database connection pool > 90% for 3 minutes
  - Stellar hot wallet balance < $1000 USDC
  - Any service down (health check fails)
  - Celery queue length > 1000 jobs

Warning Alerts (Slack - within 30 min):
  - Error rate > 0.5% for 10 minutes
  - API response time P95 > 500ms for 10 minutes
  - Database connection pool > 80% for 10 minutes
  - Redis memory > 80%
  - CPU usage > 80% for 15 minutes
  - Failed Stellar transactions > 5 in 10 minutes
  - KYC verification queue > 50 pending

Info Alerts (Email - daily digest):
  - Daily transaction volume report
  - Daily user growth report
  - Failed background jobs summary
  - Performance trends (degrading over time)
```

---

## Maintenance & Updates

### Update Schedule

```yaml
Dependencies:
  - Security patches: Within 48 hours of disclosure
  - Minor updates: Monthly (first Monday)
  - Major updates: Quarterly (after thorough testing)

Framework Updates:
  - React/React Native: Quarterly (test in staging first)
  - FastAPI: Quarterly
  - Python: Annually (3.11 → 3.12, etc.)
  - Node.js: Every 6 months (LTS versions only)

Database:
  - PostgreSQL minor: Quarterly
  - PostgreSQL major: Annually (with migration plan)

Infrastructure:
  - OS patches: Automated (managed by Railway/Vercel)
  - Container updates: Monthly
```

### Backup Strategy

```yaml
Database (Supabase):
  - Automated daily backups (full)
  - Point-in-time recovery (last 7 days)
  - Retention: 30 days
  - Location: Same region + cross-region replica
  - Backup verification: Weekly restore test

Redis (Upstash):
  - Automated snapshots every 6 hours
  - Retention: 7 days
  - AOF (Append-Only File) persistence enabled

Code & Configuration:
  - Version controlled in Git (GitHub)
  - Tagged releases for every production deploy
  - Environment variables backed up in 1Password

User Files (S3):
  - Versioning enabled
  - Cross-region replication
  - Lifecycle policy: Archive to Glacier after 90 days
  - Retention: Indefinite (compliance requirement)
```

### Disaster Recovery

```yaml
RTO (Recovery Time Objective): 4 hours
RPO (Recovery Point Objective): 1 hour

Recovery Scenarios:

1. Database failure:
   - Restore from latest Supabase backup (15 minutes)
   - Repoint application to restored database
   - Verify data integrity
   - Total time: < 1 hour

2. Backend service failure:
   - Redeploy last known good version
   - Scale up additional instances
   - Total time: < 15 minutes

3. Complete region failure:
   - Failover to secondary region (if configured)
   - Restore database from cross-region backup
   - Update DNS records
   - Total time: < 4 hours

4. Data corruption:
   - Identify scope of corruption
   - Restore from point-in-time backup
   - Replay transactions from audit logs
   - Total time: 2-4 hours

Recovery Process:
1. Declare incident
2. Notify team via PagerDuty
3. Execute recovery plan
4. Verify system health
5. Resume normal operations
6. Post-mortem within 24 hours

Tested: Quarterly disaster recovery drill
```

---

## Document Maintenance

**Review Frequency:** Quarterly or when major architectural changes occur

**Update Triggers:**

- New technology adoption (e.g., switching from Railway to AWS)
- Major refactoring (e.g., splitting monolith into microservices)
- Security updates (e.g., new authentication method)
- Performance optimization changes (e.g., new caching layer)
- New external integrations (e.g., adding new payment provider)
- Compliance requirements (e.g., new regulations)

**Version History:**

| Version | Date       | Changes              | Author      |
| ------- | ---------- | -------------------- | ----------- |
| 1.0     | 2024-12-20 | Initial architecture | [Tu Nombre] |

---

## Appendix

### Glossary

**USDC:** USD Coin, stablecoin pegged 1:1 to US Dollar  
**Stellar:** Blockchain network for fast, low-cost transfers  
**Hot Wallet:** Online wallet for active transactions  
**Cold Wallet:** Offline wallet for long-term storage  
**KYC:** Know Your Customer (identity verification)  
**NFC:** Near Field Communication (contactless payment)  
**QR:** Quick Response code for payments  
**P2P:** Peer-to-peer (user to user)  
**B2P:** Business-to-person (company to individual)  
**TPV:** Terminal Punto de Venta (payment terminal)  
**IFPE:** Institución de Fondos de Pago Electrónico (Mexican fintech license)  
**CNBV:** Comisión Nacional Bancaria y de Valores (Mexican financial regulator)

### Key Design Decisions

**Why Stellar over Ethereum/Polygon?**

- Transaction cost: ~$0.00001 vs $0.50-5.00
- Speed: 3-5 seconds vs 30+ seconds
- Designed for payments (not general computation)
- Native multi-currency support
- Battle-tested for remittances (used by MoneyGram, Coinbase)

**Why FastAPI over Node.js?**

- Native async/await support (critical for blockchain calls)
- Automatic API documentation (OpenAPI/Swagger)
- Type safety with Pydantic
- Performance comparable to Node.js
- Strong Python ecosystem for ML/data (future features)

**Why React Native over Flutter?**

- Code reuse with web app (React)
- Better NFC support on iOS/Android
- Larger community and package ecosystem
- Expo simplifies deployment
- TypeScript consistency across all codebases

**Why Supabase over self-hosted PostgreSQL?**

- Managed backups and HA
- Built-in auth (saves development time)
- Real-time subscriptions (for live balance updates)
- Generous free tier
- Easy scaling
- Can migrate to self-hosted later if needed

**Why two separate mobile apps (User + Business)?**

- Different user flows and UX needs
- Cleaner codebase (separation of concerns)
- Easier to optimize for each use case
- Better App Store optimization (different keywords)
- Can iterate on each independently

### External Resources

- [Stellar Documentation](https://developers.stellar.org/)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [React Native Documentation](https://reactnative.dev/)
- [Expo Documentation](https://docs.expo.dev/)
- [Supabase Documentation](https://supabase.com/docs)
- [Circular API Docs](https://docs.circle.com/)
- [Bitso API Docs](https://bitso.com/api_info)

---

**Last Updated:** 2024-12-20  
**Next Review:** 2025-03-20  
**Maintained by:** [Tu Nombre]

**Questions or Suggestions?**  
Open an issue on GitHub or contact the team via Slack #engineering

---

**End of ARCHITECTURE.md v1.0**
